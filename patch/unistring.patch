--- lib/unilbrk/u8-possible-linebreaks.c
+++ lib/unilbrk/u8-possible-linebreaks.c
@@ -46,9 +46,10 @@
   char *seen_space2 = NULL; /* At least two spaces after the last non-space? */

   /* Don't break inside multibyte characters.  */
-  memset (p, UC_BREAK_PROHIBITED, n);
+  if (p)
+      memset (p, UC_BREAK_PROHIBITED, n);

-  while (s < s_end)
+  while (s < s_end)
     {
       ucs4_t uc;
       int count = u8_mbtouc_unsafe (&uc, s, s_end - s);
--- lib/unistr/u8-cmp.c
+++ lib/unistr/u8-cmp.c
@@ -35,5 +35,6 @@
 u8_cmp (const uint8_t *s1, const uint8_t *s2, size_t n)
 {
   /* Use the fact that the UTF-8 encoding preserves lexicographic order.  */
+  if (n == 0) return 0;
   return memcmp ((const char *) s1, (const char *) s2, n);
 }
--- lib/uniconv/u8-conv-from-enc.c
+++ lib/uniconv/u8-conv-from-enc.c
@@ -86,7 +86,8 @@
             }
         }

-      memcpy ((char *) result, src, srclen);
+      if (result && src)
+         memcpy ((char *) result, src, srclen);
       *lengthp = srclen;
       return result;
     }
--- lib/unictype/numeric.c
+++ lib/unictype/numeric.c
@@ -49,7 +49,7 @@
               /* level3 contains 8-bit values, packed into 16-bit words.  */
               unsigned int lookup3 =
                 ((u_numeric.level3[index3>>4]
-                  | (u_numeric.level3[(index3>>4)+1] << 16))
+                  | ((unsigned int)(u_numeric.level3[(index3>>4)+1]) << 16))
                  >> (index3 % 16))
                 & 0xff;

--- lib/unilbrk/u16-possible-linebreaks.c
+++ lib/unilbrk/u16-possible-linebreaks.c
@@ -46,9 +46,10 @@
   char *seen_space2 = NULL; /* At least two spaces after the last non-space? */

   /* Don't break inside multibyte characters.  */
-  memset (p, UC_BREAK_PROHIBITED, n);
+  if (p)
+      memset (p, UC_BREAK_PROHIBITED, n);

-  while (s < s_end)
+  while (s < s_end)
     {
       ucs4_t uc;
       int count = u16_mbtouc_unsafe (&uc, s, s_end - s);
