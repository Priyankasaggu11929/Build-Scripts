--- src/iconv.c
+++ src/iconv.c
@@ -836,12 +836,14 @@
 
 /* ========================================================================= */
 
+/* Be sure the handle is closed on exit when destructors are available */
+static iconv_t std_cd;
+
 int main (int argc, char* argv[])
 {
   const char* fromcode = NULL;
   const char* tocode = NULL;
   int do_list = 0;
-  iconv_t cd;
   struct iconv_fallbacks fallbacks;
   struct iconv_hooks hooks;
   int i;
@@ -1015,15 +1017,15 @@
       fromcode = "char";
     if (tocode == NULL)
       tocode = "char";
-    cd = iconv_open(tocode,fromcode);
-    if (cd == (iconv_t)(-1)) {
-      if (iconv_open("UCS-4",fromcode) == (iconv_t)(-1))
+    std_cd = iconv_open(tocode,fromcode);
+    if (std_cd == (iconv_t)(-1)) {
+      if ((iconv_open("UCS-4",fromcode)) == (iconv_t)(-1))
         error(0,0,
               /* TRANSLATORS: An error message.
                  The placeholder expands to the encoding name, specified through --from-code.  */
               _("conversion from %s unsupported"),
               fromcode);
-      else if (iconv_open(tocode,"UCS-4") == (iconv_t)(-1))
+      else if ((iconv_open(tocode,"UCS-4")) == (iconv_t)(-1))
         error(0,0,
               /* TRANSLATORS: An error message.
                  The placeholder expands to the encoding name, specified through --to-code.  */
@@ -1085,15 +1087,15 @@
       fallbacks.wc_to_mb_fallback =
         (ilseq_wchar_subst != NULL ? subst_wc_to_mb_fallback : NULL);
       fallbacks.data = NULL;
-      iconvctl(cd, ICONV_SET_FALLBACKS, &fallbacks);
+      iconvctl(std_cd, ICONV_SET_FALLBACKS, &fallbacks);
     }
     /* Set up hooks for updating the line and column position. */
     hooks.uc_hook = update_line_column;
     hooks.wc_hook = NULL;
     hooks.data = NULL;
-    iconvctl(cd, ICONV_SET_HOOKS, &hooks);
+    iconvctl(std_cd, ICONV_SET_HOOKS, &hooks);
     if (i == argc)
-      status = convert(cd,fileno(stdin),
+      status = convert(std_cd,fileno(stdin),
                        /* TRANSLATORS: A filename substitute denoting standard input.  */
                        _("(stdin)"));
     else {
@@ -1111,12 +1113,13 @@
                 infilename);
           status = 1;
         } else {
-          status |= convert(cd,fileno(infile),infilename);
+          status |= convert(std_cd,fileno(infile),infilename);
           fclose(infile);
         }
       }
     }
-    iconv_close(cd);
+    iconv_close(std_cd);
+    std_cd = (iconv_t)0;
   }
   if (ferror(stdout) || fclose(stdout)) {
     error(0,0,
@@ -1126,3 +1129,24 @@
   }
   exit(status);
 }
+
+/* Leak check tooling like Valgrind and Asan */
+#if defined(__GNUC__) && defined(__linux__)
+__attribute__((destructor))
+static void
+do_cleanup (void)
+{
+  if (std_cd > (iconv_t)0)
+    iconv_close(std_cd);
+  if (subst_mb_to_uc_cd > (iconv_t)0)
+    iconv_close(subst_mb_to_uc_cd);
+  if (subst_uc_to_mb_cd > (iconv_t)0)
+    iconv_close(subst_uc_to_mb_cd);
+  if (subst_mb_to_wc_cd > (iconv_t)0)
+    iconv_close(subst_mb_to_wc_cd);
+  if (subst_wc_to_mb_cd > (iconv_t)0)
+    iconv_close(subst_wc_to_mb_cd);
+  if (subst_mb_to_mb_cd > (iconv_t)0)
+    iconv_close(subst_mb_to_mb_cd);
+}
+#endif
--- tests/test-shiftseq.c
+++ tests/test-shiftseq.c
@@ -58,8 +58,13 @@
     */
     if (!(r == (size_t)(-1) && errno == EILSEQ
           && inptr - input == 1 && outptr - buf == 0))
+    {
+      iconv_close(cd);
       abort();
+    }
   }
+  if (cd > (iconv_t)0)
+    iconv_close(cd);
 }
 
 void main2 (void)
@@ -92,7 +97,10 @@
     */
     if (!(r == (size_t)(-1) && errno == EINVAL
           && inptr - input == 1 && outptr - buf == 0))
+    {
+      iconv_close(cd);
       abort();
+    }
 
     inleft = input + 20 - inptr;
     r = iconv (cd, (ICONV_CONST char **) &inptr, &inleft, &outptr, &outleft);
@@ -106,8 +114,13 @@
     */
     if (!(r == (size_t)(-1) && errno == EILSEQ
           && inptr - input == 1 && outptr - buf == 0))
+    {
+      iconv_close(cd);
       abort();
+    }
   }
+  if (cd > (iconv_t)0)
+    iconv_close(cd);
 }
 
 int main ()
