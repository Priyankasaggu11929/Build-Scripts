--- src/global.c
+++ src/global.c
@@ -41,8 +41,6 @@
 #include "secmem.h" /* our own secmem allocator */
 
 
-
-
 /****************
  * flag bits: 0 : general cipher debug
  *	      1 : general MPI debug
@@ -79,8 +77,6 @@
 /* Prototypes.  */
 static gpg_err_code_t external_lock_test (int cmd);
 
-
-
 
 /* This is our handmade constructor.  It gets called by any function
    likely to be called at startup.  The suggested way for an
@@ -173,8 +169,6 @@
 }
 
 
-
-
 /* Version number parsing.  */
 
 /* This function parses the first portion of the version number S and
@@ -222,6 +216,7 @@
     return s; /* patchlevel */
 }
 
+
 /* If REQ_VERSION is non-NULL, check that the version of the library
    is at minimum the requested one.  Returns the string representation
    of the library version if the condition is satisfied; return NULL
@@ -297,6 +292,10 @@
                      "clang:" __VERSION__
 #elif __GNUC__
                      "gcc:" __VERSION__
+#elif __SUNPRO_C
+		     "SunC: 0x" #__SUNPRO_C
+#elif __INTEL_COMPILER
+		     "icc: " #__INTEL_COMPILER
 #else
                      ":"
 #endif
--- mpi/mpiutil.c
+++ mpi/mpiutil.c
@@ -32,6 +32,21 @@
 static gcry_mpi_t constants[MPI_NUMBER_OF_CONSTANTS];
 
 
+/* Best effort attempt to cleanup constants array. */
+#if defined(__GNUC__)
+__attribute__((destructor))
+static void
+mpi_array_cleanup()
+{
+  int idx;
+  for (idx=0; idx < MPI_NUMBER_OF_CONSTANTS; idx++)
+    {
+      constants[idx]->flags &= ~32U;
+      _gcry_mpi_free(constants[idx]);
+    }
+}
+#endif
+
 
 const char *
 _gcry_mpi_get_hw_config (void)
--- tests/mpitests.c
+++ tests/mpitests.c
@@ -35,6 +35,17 @@
 #define PGM "mpitests"
 #include "t-common.h"
 
+/* From mpi.h. The shadow struct is valid for libgcrypt 1.8.4.
+   The shadow struct may not hold if gcry_mpi_t changes in
+   future versions of the library. */
+struct hack_gcry_mpi
+{
+  int alloced;
+  int nlimbs;
+  int sign;
+  unsigned int flags;
+  void *d;
+};
 
 /* Set up some test patterns */
 
@@ -149,6 +158,14 @@
   /* Due to the the constant flag the release below should be a NOP
      and will leak memory.  */
   gcry_mpi_release (one);
+
+  /* Hack... free the memory to avoid warnings and errors from tooling.
+     This compliments the release performed on 'one' above. If we avoid
+     the double-free then GCRYMPI_FLAG_CONST is working as expected,
+     and we avoid the memory leak that breaks acceptance testing. */
+  ((struct hack_gcry_mpi*)one)->flags &= ~32U;
+  gcry_mpi_release (one);
+
   return 1;
 }
 
